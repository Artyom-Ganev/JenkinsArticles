Jenkins: облако по требованию
=============================

[Jenkins](https://jenkins.io/ "Домашняя страница проекта Jenkins") - открытый сервер непрерывной интеграции (CI) и
поставки (DI) программного кода. Это весьма мощный и гибкий инструмент, позволяющий решать очень широкий спектр задач.
Это достигается за счёт большого количества расширений, доступных для установки.

В тоже время большое количество всевозможных расширений может весьма сильно дезориентировать новичка. Из-за слишком
большого выбора возможных путей для решения текущей задачи может уйти весьма много времени на поиск наиболее
оптимального решения.


Прежде всего стоит сказать, что многие вещи в Jenkins
(особенно новый [Pipeline Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Pipeline+Plugin))
рассчитаны на использование master-slave конфигурации. Даже если для Jenkins используется только один компьютер, то
всё равно имеет смысл запустить и мастер и один слейв вместе. Чтобы все задачи выполнялись именно на слейве.

Само развёртывание будем производить с помощью Docker, т.к. это упрощает обновление мастера и позволит значительно
упростить работу со слейвами за счёт плагинов автоматизирующих масштабирование.

Установка мастера
-----------------
Проект Jenkins предоставляет готовый Docker образ. Если у вас нету никаких специальных требований то можно использовать
прямо его.

```bash
docker run --name jenkins \
    -p 8080:8080 \
    -p 50000:50000 \
    -v /storage/jenkins2:/var/jenkins_home:rw \
    --detach \
    --restart=unless-stopped \
    jenkinsci/jenkins
```

Тут мы запускаем мастер Jenkins и задаём следующие параметры (по порядку)
1. Задаём имя контейнера
2. Пробрасываем порты для WEB интерфейса и для подключения слейвов
3. Монтируем рабочий каталог, где будут располагаться все персистентные данные
4. Делаем контейнер отсоединённым от консоли (чтобы не закрылся вместе с сессией ssh)
5. Говорим контейнеру, что он должен стартовать вместе с OS и перезапускаться при падении (пока не будет явно остановлен
   администратором)

**Внимание!** Образ jenkinsci/jenkins содержит Jenkins версии 2.x которая хоть и имеет статус релиза, но находится
в активной разработке. Если вам необходима стабильная версия сервера, то используйте образ ``

Для Debian based дистрибутивов этого будет достаточно. Но на Red Hat дистрибутивах (CentOS в моём случае) контейнер
нужно дополнительно подружить с SELinux, который, в противном случае, не даст писать в примонтированный каталог. Для
этого модифицируем строку запуска следующим образом:

```bash
docker run --name jenkins \
    -p 8080:8080 \
    -p 50000:50000 \
    -v /storage/jenkins2:/var/jenkins_home:Z \
    --detach \
    --restart=unless-stopped \
    --security-opt label:disable \
    jenkinsci/jenkins
```

Т.е. отключаем проверки SELinux для самого контейнера и просим Docker добавить себе права на запись в рабочий каталог.
Возможно такой подход и несколько топорный, но в данном случае большего и не требуется.

В принципе этого может быть достаточно для простых ситуаций, но в моём же случае возникло ряд сложностей:

1. Закрытая сеть: доступ в интернет только через прокси
2. Необходимо дополнительное ПО. В моём случае нужен Mercurial
3. Дефолтные настройки Jenkins не соответствуют требованиям

В этой ситуации можно унаследовать Dockerfile и доконфигурировать приложение:

```dockerfile
FROM jenkinsci/jenkins

USER root
RUN echo 'Acquire::http::Proxy "http://proxy.organization.ru:8080";' >> /etc/apt/apt.conf &&\
    apt-get -q update &&\
    DEBIAN_FRONTEND="noninteractive" apt-get -q install -y -o Dpkg::Options::="--force-confnew"  --no-install-recommends mercurial &&\
    apt-get -q autoremove &&\
    apt-get -q clean -y && rm -rf /var/lib/apt/lists/* && rm -f /var/cache/apt/*.bin
USER jenkins

ENV JENKINS_OPTS --httpPort=18080
ENV JAVA_OPTS "-Xmx2g -Duser.timezone=Europe/Moscow -Dhudson.model.DirectoryBrowserSupport.CSP= -Dhttp.proxyHost=proxy.organization.ru -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.organization.ru -Dhttps.proxyPort=8080 -Dhttp.nonProxyHosts='*.organization.ru|localhost|10.0.*'"
ENV http_proxy "http://proxy.organization.ru:8080"
ENV https_proxy "http://proxy.organization.ru:8080"
ENV no_proxy "organization.ru,localhost"

EXPOSE 18080 50000 22222
```

Разберём, что делает этот файл:
1. Контекст переключается под пользователя root и устанавливает Mercurial через apt-get. Только Mercurial без
дополнительных зависимостей. Причём в начале конфигурируется прокси для apt, а в конце производится полная чистка
мусора, чтобы не увеличивать без надобности итоговый образ
2. Контекст переключается обратно под пользователя jenkins и устанавливается набор переменных окружения для тюнинга
Jenkins и для задания прокси.
    1. **JENKINS_OPTS** - изменяем порт, на котором будет работать Jenkins внутри контейнера
    2. **JAVA_OPTS** - изменяем параметры запуска JVM. В частности устанавливаем временную зону и отключаем безопасность
       для браузера (нужно для публикации таких вещей, как JavaDoc, при том, что публикуемому содержимому мы полностью
       доверяем)
    3. **http_proxy/https_proxy/no_proxy** - настройка прокси на уровне ОС контейнера
3. Объявляем новый набор портов. Порт 22222 понадобится в будущем. Там у нас будет git репозитарий для Pipeline Plugin
   по протоколу ssh

Собираем новый образ и запускаем его:

```
docker build --no-cache --force-rm --tag organization/jenkins-custom .
docker run --security-opt label:disable -p 8080:18080 -p 50000:50000 -p 22222:22222 --name jenkins --detach --restart=unless-stopped -v /storage/jenkins2:/var/jenkins_home:Z organization/jenkins-custom
```

Теперь сервер Jenkins доступен по адресу [http://localhost:8080](http://localhost:8080). Можно приступать к настройке
слейвов.

Настройка запуска слейвов
-------------------------

Слейвы Jenkins могут работать по двум протоколам: ssl и jnlp. Для обоих вариантов предоставляются Docker образы.
Контейнеры из этих образов должны быть запущены вручную и обновляться вместе с контейнером мастера.

Такой подход не может считаться достаточно гибким, т.к. требует много ручной работы. К тому же свежие образы не всегда
выкладываются синхронно, что может приводить к проблемам обновления.

Чтобы решить эти проблемы у Jenkins существует плагин с говорящим названием
[Yet Another Docker Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Yet+Another+Docker+Plugin) (т.к. был создан по
мотивам [другого плагина](https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin) с гораздо меньшей
функциональностью). Он позволяет автоматически поднимать слейвы в Docker контейнерах на удалённых компьютерах. Причём
без привязки к конкретной версии Jenkins, т.к. исполняемый код слейва выкачивается каждый раз с мастера.
Что позволяет больше не беспокоиться о совместимости версий. И при этом имеет крайне гибкие настройки.

### Настройка Docker

Итак. Что нам нужно для настройки этого плагина? Прежде всего необходимо установить и настроить Docker на тех машинах,
где предполагается запускать слейвы. Для простоты можно начать с запуска на том же компьютере, где и мастер (напомню,
что если запускать задачи прямо на мастере, то в том же Pipeline Plugin'е можно схлопотать много неожиданностей).

**Замечание:** далее описание настройки будет приводится для RedHat based дистрибутивов (RedHat 7, SentOS 7 и т.п.),
т.к. основной опыт настройки был получен именно под этим типом дистрибутивов.

Сначала ставим Docker:
```bash
yum install docker
```

По умолчанию сервис Docker'а принимает команды только по файловому сокету. Но для наших целей нужно, чтобы помимо этого
он работал и по сети.

Чтобы открыть управление Docker'ом по сети, необходимо отредактировать файл `/etc/sysconfig/docker` и привести его к
следующему виду:
```
# /etc/sysconfig/docker

OPTIONS='--selinux-enabled -H tcp://0.0.0.0:4243 -H unix:///var/run/docker.sock'

DOCKER_CERT_PATH=/etc/docker
```

### Подготовка Docker образа для запуска слейва

Для работы с Yet Another Docker Plugin нужно использовать не стандартные образы слейвов, а другие, специально
подготовленные, образы. В случае, если для подключения слейва используется протокол ssh, то можно использовать
образ `evarga/jenkins-slave`. А если используется протокол jnlp (что рекомендуется), то лучше использовать образ
`kostyasha/jenkins-slave:jdk-wget` от автора Yet Another Docker Plugin. Лично я, после некоторых экспериментов,
остановил свой выбор на втором варианте, т.к. в этом случае меньше грузится мастер и соейвы быстрее стартуют.

Только, как и в случае с мастером, пришлось несколько дополнить образ, добавив туда поддержку Mercurial и корпоративного
прокси:
```
FROM kostyasha/jenkins-slave:jdk-wget

ENV JAVA_OPTS "-Xmx2g -Duser.timezone=Europe/Moscow -Dhudson.model.DirectoryBrowserSupport.CSP= -Dhttp.proxyHost=proxy.organization.ru -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.organization.ru -Dhttps.proxyPort=8080 -Dhttp.nonProxyHosts='*.organization.ru|localhost|10.0.*'"
ENV http_proxy "http://proxy.organization.ru:8080"
ENV https_proxy "http://proxy.organization.ru:8080"
ENV no_proxy "organization.ru,localhost"

RUN echo "proxy=http://proxy.organization.ru:8080" >> /etc/yum.conf &&\
    cat /etc/yum.conf &&\
    yum -y install mercurial &&\
    ln -s /home/jenkins /var/jenkins_home
```

В целом всё аналогично с Dockerfile'ом для мастера. Только в последней строчке есть маленькая хитрость. Дело в том, что
образ мастера настроен так, чтобы рабочий каталог Jenkins находился по пути `/var/jenkins_home`. А в образ для слейва
заложен путь `/home/jenkins`. Что может приводить к нестыковкам. Для решения этой проблемы я просто добавил создание
симлинка. Возможно это как-то можно решить более правильно, но с наскоку я смог придумать только такое решение.

### Настройка Yet Another Docker Plugin

**ПРЕДУПРЕЖДЕНИЕ:** Yet Another Docker Plugin находится в стадии активной разработки и может содержать различные
недочёты. Использовать его можно только на собственный страх и риск.

Прежде всего нужно гарантировать, что задачи будут запускаться только на слейвах, но не на мастере. Иначе у мастера может
не остаться ресурсов для управления этими самыми слейвами.

Для этого устанавливаем метки в настройках мастера:

![settings01]

**Примечание:** У каждого узла можно указывать несколько меток через пробел. Тогда, чтобы задача запустилась именно на
этом узле можно указать любую из этих меток или их комбинацию.

Далее устанавливаем `Yet Another Docker Plugin` и в настройках Jenkins появляется раздел `Cloud` с кнопкой
`Add new cloud`, где можно добавить новое облако:

![settings02]

После добавления облака нужно задать его глобальные настройки:

![settings03]

* **Cloud Nmae** - имя облака. Желательно без пробелов и других экзотических символов
* **Docker URL** - адрес сервиса Docker. Тут можно указать как адрес отдельного компьютера, так и целый
[Swarm кластер](https://docs.docker.com/swarm/overview/)
* **Max Containers** - масксимальное количество контейнеров, которое будет поднимать плагин в рамках данного облака

После настройки не забываем нажать `Test Connection`, чтобы убедиться, что мастер действительно видит Docker на целевой
машине.

Далее добавляем шаблон развёртывания слейва. Жмём `Add Docker Template` и выбираем `Docker Template`. Появляется блок
в котором нужно настроить что и как запускать для старта слейва. Разберём по порядку:

![settings04]

* **Max Instances** - Ещё одно ограничение, но уже для конкретного шаблона. В итоговой конфигурации нужно отталкиваться
  от потребности, но во время настройки лучше поставить поменьше, чтобы в случае ошибки не получить взрыв контейнеров.
  О причинах см. ниже
* **Docker Image Name** - собственно имя Docker образа, из которого будут создаваться контейнеры для запуска слейвов.
  Тут указываем тот, образ, о котором шла речь в предыдущем разделе

Ниже настраиваем параметры запуска уже самого слейва внутри контейнера:

![settings05]

* **Remote Filing System Root** - указываем где в образе находится домашний каталог Jenkins
* **Label** - указываем метки, которые будут присвоены запускаемым слейвам
* **Launch method** - Т.к. у нас образ предназначен для запуска слейва по протоколу JNLP, то выбираем именно этот
  вариант.
* **Linux user** - пользователь, под которым должен стартовать процесс слейва. В нашем образе это пользователь `jenkins`
* **JVM options** - опции запуска JVM по вкусу

Это минимум, который нужно настроить для запуска слейва. Но на самые интересные настройки появляются, если нажать кнопку
`Container Settings...`:

![settings06]

Тут можно задавать разнообразные настройки запуска контейнера, раскрывающие всю мощь Docker'а. Самая главная настройка -
`Volumes`, которая позволяет подмонтировать внешний каталог внутрь контейнера и тем самым сохранять состояние сборки
между запусками слейвов.

Ещё, т.к. на стенде я настраивал мастер и слейвы на одном и том же компьютере, я снизил приоритет процессов внутри
слейвов опцией `CPU Shares`, чтобы запускаемые задачи не мешали мастеру.

Так же тут есть ещё много всяких замечательных настроек, которые могут позволить очень тонко настраивать запускаемые
контейнеры. Например эмулировать различные окружения для нагрузочного тестирования и т.п. За подробностями можно
обратиться к
[соответствующему разделу документации](https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources).

Дополнительные замечания
------------------------

В этой статье я при вёл настройки мастер-лейв конфигурации практически в таком виде, как настроил у себя на стенде.
И этот стенд отлично работает уже пару недель без каких-либо нареканий. Но вот достичь этого результата удалось далеко
не сразу. Тут я постараюсь описать основные грабли, на которые я наткнулся.

###"Взрыв" контейнеров

В процессе экспериментов у меня несколько раз получалось, что мастер начинал бесконтрольно плодить контейнеры со
слейвами. Часть из этих проблем была связана с ошибками в Yet Another Docker Plugin, на которые я исхитрился наступить.
И совместно с автором плагина эти ошибки были справлены. Но были и ситуации, когда виновником взрыва был я сам.

В основном это происходило из-за того, что мастер после запуска контейнера, ждёт, внутри последнего запустится слейв
и просигналит о том, что он готов принимать задачи на исполнение. Если сигнала от слейва не пришло, то просто запускает
ещё один контейнер со слейвом. Но предыдущий при этом может остаться висеть в системе. И если лимиты на количество
запущенных слейвов не выставлены, или выставлены в большие значения, то вполне возможно придётся потратить большое
количество времени на чистку мусора.

Причиной же такого поведения, прежде всего, является недоступность порта 50000 со стороны мастера, по которому должен
общаться слейв при JNLP протоколе. Ну или если используется другой порт и эта настройка несогласованна между мастером
и слейвом.

Именно поэтому я и рекомендую на момент настройки Jenkins выставлять эти значения в минимальные значения.

###JNLP vs. SSH

Как-то так сложилось, что у меня выработалось весьма высокое доверие к SSH. И когда встал выбор как запускать слейвы, то
выбор сперва пал именно на этот вариант. Но вот с реализацией с самого начала не заладилось. Мало того, что мне
приходится пересобирать стандартные образы под себя из-за корпоративного прокси, так ещё и сам ssh потребовал много
дополнительных подпрыгиваний. А в результате получил вариант, который относительно медленно стартует и безосновательно
грузит мастер. В целом этот вариант не заслуживает особого внимания, но кому интересно - вот Dockerfile для сборки
образа, который у меня получился:

```
# This Dockerfile is used to build an image containing basic stuff to be used as a Jenkins slave build node.
FROM ubuntu:trusty

# In case you need proxy
RUN echo 'Acquire::http::Proxy "http://proxy.organization.ru:8080";' >> /etc/apt/apt.conf

# Upgrade packages on image
RUN apt-get -q update &&\
    DEBIAN_FRONTEND="noninteractive" apt-get -q upgrade -y -o Dpkg::Options::="--force-confnew" --no-install-recommends &&\
    DEBIAN_FRONTEND="noninteractive" apt-get -q install -y -o Dpkg::Options::="--force-confnew"  --no-install-recommends openssh-server mercurial &&\
    apt-get -q autoremove &&\
    apt-get -q clean -y && rm -rf /var/lib/apt/lists/* && rm -f /var/cache/apt/*.bin &&\
    sed -i 's|session    required     pam_loginuid.so|session    optional     pam_loginuid.so|g' /etc/pam.d/sshd &&\
    mkdir -p /var/run/sshd &&\
    /usr/bin/ssh-keygen -A

# Install JDK 7 (latest edition)
RUN apt-get -q update &&\
    DEBIAN_FRONTEND="noninteractive" apt-get -q install -y -o Dpkg::Options::="--force-confnew"  --no-install-recommends openjdk-7-jre-headless &&\
    apt-get -q clean -y && rm -rf /var/lib/apt/lists/* && rm -f /var/cache/apt/*.bin

# Set user jenkins to the image
RUN useradd -m -d /home/jenkins -s /bin/sh jenkins &&\
    echo "jenkins:jenkins" | chpasswd &&\
    ln -s /home/jenkins /var/jenkins_home

ENV JAVA_OPTS "-Duser.timezone=Europe/Moscow -Xmx2g -Dhudson.model.DirectoryBrowserSupport.CSP= -Dhttp.proxyHost=proxy.organization.ru -Dhttp.proxyPort=8080 -Dhttps.proxyHost=proxy.organization.ru -Dhttps.proxyPort=8080 -Dhttp.nonProxyHosts='*.organization.ru|localhost|10.0.*'"
ENV http_proxy "http://proxy.organization.ru:8080"
ENV https_proxy "http://proxy.organization.ru:8080"
ENV no_proxy "organization.ru,localhost"

# Standard SSH port
EXPOSE 22

# Default command
CMD ["/usr/sbin/sshd", "-D"]
```

Заключение
----------

Итак. Что мы имеем в итоге: Развёрнутый и готовый к работе сервер Jenkins в режиме master-lave. Причём слейвы создаются
строго по мере необходимости в Docker контейнерах. Можно легко подключать произвольное количество серверов к мастеру
для запуска слейвов. Для этого нужно на целевой сервер просто установить Docker, открыть к нему доступ по сети и
прописать сервер у мастера в конфигурации.

И что самое главное: не нужно следить за актуальностью слейвов. Если обновляется мастер, то все слейвы сами подхватят
новый jar файл для запуска процесса слейва.

Ну и в завершение хочу высказать глубокую благодарность:
* @kostyasha - за создание замечательного плагина к Jenkins и помощь в его настройке
* @oleg-nenashev - за бесценные консультации по настройке Jenkins в целом

[settings01]: images/settings01.png "Настройка меток"
[settings02]: images/settings02.png "Кнопка добавления облака  слейвов"
[settings03]: images/settings03.png "Настройки облака"
[settings04]: images/settings04.png "Настройки контейнера"
[settings05]: images/settings05.png "Настройки запуска слейва"
[settings06]: images/settings06.png "Настройки запуска контейнера"